#!/bin/bash

# TODO:
#   - Use PolicyKit instead of sudo for authentication.
#   - Add a post-transfer file integrity check for $SNAPS_DIR?

# =============================================================================
# This script does the following:
# 1. Creates a dictionary of information about local snaps.
#       Start with seeds.
#       Add/overwrite from installed snaps, keeping highest revisions.
# 2. Creates a dictionary of snaps and revisions in SNAPS_DIR
# 3. Determines which snaps should be copied.
# 4. Creates assert files for all installed snaps that should be copied.
# 5. Copies each snap and its assert to SNAPS_DIR.
# 6. Removes extra snaps from SNAPS_DIR.
# =============================================================================

# Require root privileges.
# -----------------------------------------------------------------------------
if [ $(id -u) -ne 0 ]; then
    # Filling in for now for more elaborate handling.
    echo "This script needs to be run with root privileges. Exiting."
    exit 1
fi


# Set global variables
# -----------------------------------------------------------------------------
USAGE_TEXT="usage: $0 [OPTIONS] [/path/to/dest]"
HELP_TEXT="$USAGE_TEXT

This app copies local snaps and assert files to a given destination for
installation on other systems. If no options or args are passed, the
destination will be requested interactively.
    
    -h              Show this help text.
    -k [number]     Choose how many snap revisions to keep. Default is 2.
    /path/to/dest   Directory for storing offline snaps.
"

# Default number of snap revisions kept in offline folder.
MAX=2

# Evaluate options.
while getopts ":hk:" opt; do
    case $opt in
        h) # help requested
            echo "$HELP_TEXT"
            exit 0
            ;;
        k) # MAX num of kept snaps specified
            if [[ $OPTARG -ge 1 ]]; then
                MAX="$OPTARG"
            else
                echo "Error: At least 1 revision of each snap must be kept."
                exit 1
            fi
            ;;
        /?) # invalid option
            echo "$USAGE_TEXT"
            exit 1
    esac
done
shift $((OPTIND-1))

# Determine script mode.
if [[ $1 ]]; then
    # Arg passed, consider the script to be in non-interactive mode.
    AUTO=1
else
    AUTO=0
fi

# Clean up argument if passed.
SNAPS_DIR=$(realpath "$1" 2>/dev/null) # realpath removes trailing '/'s

# System info
LOG_DATE=$(date +%F-%H-%M)
HOST=$(uname -n)

# Zenity defaults
ZTITLE="wasta [Offline] Snap Setup"
ZHEIGHT=200
ZWIDTH=500
ZICON=/usr/share/icons/hicolor/256x256/apps/wasta-offline.png
ZDEFAULTS=(--title="$ZTITLE" --height="$ZHEIGHT" --width="$ZWIDTH" --window-icon="$ZICON")

# Determine if $SUDO_USER has write access to passed $SNAPS_DIR.
#   $no_write_access will be empty if the user does have write permission.
no_write_access=$(sudo -u $SUDO_USER touch "$SNAPS_DIR"/.test-write 2>&1)
# Exit with error if invalid $SNAPS_DIR passed as argument (assumed non-interactive).
if [[ $1 ]] && [[ $no_write_access ]]; then
    # Invalid $SNAPS_DIR passed as argument.
    echo "Files cannot be created in this folder. Exiting."
    exit 1
fi

# If no argument passed, give initial prompt and get user input for $SNAPS_DIR .
count=0
while [[ $no_write_access ]]; do
    # Avoid initial prompt on subsequent loops.
    if [[ $ct -eq 0 ]]; then
        zenity --question --no-wrap "${ZDEFAULTS[@]}" \
            --text="<b>Use wasta [Offline] Snap Setup to add your computer's
    <u>local snap cache</u> to wasta [Offline]?</b>\n

    <i>You will be prompted to <b>either</b>:</i>\n
      <b>* Select</b> an <b>existing</b> <i>'wasta-offline'</i>  folder <b>or</b>\n
      <b>* Create</b> (and then <b>Select</b>) a folder of your choice.\n" 2>/dev/null
        if [[ $? -eq 1 ]]; then
            # User chose "no": exit.
            exit 1
        fi
    fi
    ((count++))

    text="Searching system for wasta-offline folder...\n\n\n\n\n"
    prog_opts="--progress --pulsate --auto-close --auto-kill --no-cancel"
    # Using $SUDO_USER to try to limit the scope of the 'find' command below.
    #   Convoluted yet functional zenity subprocess inspired by this article:
    #   http://wiki.bash-hackers.org/zenity_--progress
    wo_list=$(
        sudo -u $SUDO_USER find /media /mnt /home/$SUDO_USER \
            -name 'wasta-offline' -type d 2>/dev/null | tee >(
                zenity ${prog_opts[@]} --text="$text" "${ZDEFAULTS[@]}" \
                    2>/dev/null
                )
        )
    if [[ -z $wo_list ]]; then
        # No wasta-offline folder found. Start in user's $HOME.
        START_FOLDER=/home/"$SUDO_USER"/
    else
        for d in ${wo_list[@]}; do
            # Look for 'local-cache' subfolder of 'wasta-offline' folder.
            loc_cache=$(find "$d" -maxdepth 1 -name 'local-cache' -type d 2>/dev/null)
            if [[ $loc_cache =~ ^/media/.*$ ]]; then
                # Automatically accept 'wasta-offline' folder found somewhere under /media/...
                START_FOLDER="$d"
                break
            elif [[ $loc_cache ]]; then
                # Accept other 'wasta-offlne' folder, but let one in /media/... overrule it.
                #   In case there are more than two qualifiers, the last one found wins.
                START_FOLDER="$d"
            else
                # No "true" wasta-offline folder found.
                START_FOLDER=/home/"$SUDO_USER"/
            fi
        done
    fi

    # Store $START_FOLDER for later writing to $LOG.
    MSG+="\nstart folder:\n\t$START_FOLDER\n\n"
  
    SNAPS_DIR=$(
        zenity --file-selection --directory --filename="$START_FOLDER" \
        "${ZDEFAULTS[@]}" \
        --title="Select or Create a destination folder" 2>/dev/null
        )
    if [[ $? -ne 0 ]]; then
        # User clicked "Cancel". Exit.
        exit 1
    fi
    # Test again for write access on newly-chosen $SNAPS_DIR.
    no_write_access=$(sudo -u $SUDO_USER touch "$SNAPS_DIR"/.test-write 2>&1)
done


# Delete write-access test file.
rm -f "$SNAPS_DIR"/.test-write


# Set log location.
LOG_DIR="$SNAPS_DIR/log/wasta-offline-snap-setup"
mkdir --mode=777 --parents $LOG_DIR
LOG="$LOG_DIR/$LOG_DATE-$HOST.log"

# Need to be able to handle 2 types of $SNAPS_DIRs:
#   1. "wasta-offline" folder -> Set $SNAPS_DIR as wasta-offline/local-cache/snaps.
#   2. any other folder passed -> Set $SNAPS_DIR as passed argument.
if [[ $SNAPS_DIR =~ ^.*wasta-offline$ ]]; then
    SNAPS_DIR="$SNAPS_DIR"/local-cache/snaps
    # Make sure $SNAPS_DIR exists.
    mkdir --mode=777 --parents "$SNAPS_DIR"
fi

# $SNAPS_DIR now successfully set with $SUDO_USER having non-sudo write access.
MSG+="wasta-offline snaps location:\n\t$SNAPS_DIR\n"

# snapd API variables
#   docs: https://docs.ubuntu.com/core/en/reference/rest
SNAPD_API=http://localhost
SOCKET=/run/snapd.socket

# snapd directories
SNAPD=/var/lib/snapd
SEEDS="$SNAPD"/seed
SNAPS="$SNAPD"/snaps

# mktemp template reference
TEMPLATE="wo-snap.XXXX"


# Define functions.
# ---------------------------------------------------------------------------
# Create assert file of installed snap. These only get created if the
#   corresponding .snap file is copied to the SNAPS_DIR.
create_assert_file() {
    snap="$1"
    rev="$2"
    snap_id="$3"
    dest="$4"

    # Get account-key info of given snap.
    snap_key_info=$(snap known account-key account-id=canonical name=store)

    # Get snap-declaration info.
    snap_decl_info=$(snap known snap-declaration snap-id="$snap_id")

    # Get account info if non-Canonical snap.
    pub_id=$(echo "$snap_decl_info" | grep 'publisher-id:' \
        | tr -s ' ' | cut -d' ' -f2)

    # Canonical snaps' account ID is "canonical". Otherwise it's a long key string.
    if [[ $pub_id != 'canonical' ]]; then
        snap_acct_info=$(snap known account account-id="$pub_id")
    fi

    # Get snap revision info.
    snap_rev_info=$(snap known snap-revision snap-id="$snap_id" snap-revision="$rev")

    # Create assert file.
    outfile="$dest"/"${snap}_${rev}.assert"

    echo "$snap_key_info" > "$outfile"
    echo >> "$outfile"

    if [[ $pub_id != 'canonical' ]]; then
        echo "$snap_acct_info" >> "$outfile"
        echo >> "$outfile"
    fi

    echo "$snap_decl_info" >> "$outfile"
    echo >> "$outfile"

    echo "$snap_rev_info" >> "$outfile"
    }

# Exit script nicely by cleaning up.
script_exit() {
    ec="$1"
    pid_to_kill="$2"
    
    # Kill the passed process if still running.
    if [[ $pid_to_kill ]] && [[ $(ps --no-headers -p "$pid_to_kill") ]]; then
        kill "$pid_to_kill"
    fi
    
    # Remove temp files.
    rm -r /tmp/${TEMPLATE%.*}*
   
    # Remove snaps in $SNAPS_DIR that don't have asserts (due to incomplete copy).
    files_in_dest=$(find "$SNAPS_DIR" -type f)
    for f in ${files_in_dest[@]}; do
        if [[ $f =~ .*\.snap$ ]]; then
            if [[ ! -f ${f//.snap}.assert ]]; then
                rm $f
            fi
        fi
    done

    # TODO: Perform file integrity check for snaps in $SNAPS_DIR?
    
    exit "$ec"
    }


# Write $LOG header.
echo "-------------------------------------------------------" | tee -a "$LOG"
echo "*** Copying snaps and assertions                       " | tee -a "$LOG"
echo "-------------------------------------------------------" | tee -a "$LOG"
# Add stored info.
echo -e "$MSG" | tee -a "$LOG"


# 1. Find all installed and seeded snaps, plus other useful details.
# ---------------------------------------------------------------------------
echo "Listing seeded and installed snaps..." | tee -a "$LOG"
echo "-------------------------------------------------------" >> "$LOG"

# Get list of seeded snaps in /var/lib/snapd/seed
seeded_list=$(find "$SEEDS"/snaps -name '*.snap' 2>/dev/null)
echo -e "Seeded snaps:\n$seeded_list\n" >> "$LOG"

# Add these snap names to $snaps_local dictionary.
declare -A snaps_local
for i in ${seeded_list[@]}; do
    filename="${i##*/}"
    filetitle="${filename//.*}"
    snap="${filetitle%_*}"
    rev="${filetitle##*_}"
    size=$(stat --printf="%s" "$i")
    # Add "S" after to flag the snap as "seeded" rather than "installed".
    snaps_local["$snap"]="$rev $size S"
done

# Get list of snaps currently installed.
installed_list=$(snap list | grep -v Name)
echo -e "Installed snaps:\n$installed_list\n" >> "$LOG"

# Add these snap names to $snaps_local dictionary. Installed snaps will replace
#   seeded snaps of the same name. Installed snaps should always have an equal
#   or higher revision number than seeded snaps, so no problem.
while read -r line; do
    snap=$(echo "$line" | tr -s ' ' | cut -d' ' -f1)
    rev=$(echo "$line" | tr -s ' ' | cut -d' ' -f3)

    fileloc=$SNAPS/${snap}_${rev}.snap
    size=$(stat --printf="%s" "$fileloc")

    snaps_local["$snap"]="$rev $size I"
done <<< "$installed_list"


# 2. Create dictionary of snaps and top revision #s present in offline folder.
# ---------------------------------------------------------------------------
# Get offline snaps in $SNAPS_DIR.
available_list=$(find "$SNAPS_DIR"/ -name '*.snap')
# Build associative array of available snaps and revisions in SNAPS_DIR.
#   The revision numbers are space-delimited; e.g. ("[skype]"="54 57 ").
declare -A snaps_avail
for i in ${available_list[@]}; do
    name_rev=${i##*/}
    name_rev=${name_rev%.snap}
    rev=${name_rev##*_}
    name=${name_rev%_*}
    snaps_avail["$name"]+="$rev "
done

# Sort revisions listed for each snap, choose highest one.
declare -A snaps_top
for snap in ${!snaps_avail[@]}; do
    top=$(
        for r in ${snaps_avail[$snap]}; do
            echo $r
        done | sort -nr | head -1
        )
    snaps_top["$snap"]="$top"
done


# 3. Determine relevant snaps (and assert files) to copy over.
# ---------------------------------------------------------------------------
# Files in /var/lib/snapd/snaps are supposed to be 0600 root:root, even if some
#   are 0644 root:root (holdovers from old policy). The other option at
#   /var/lib/snapd/cache is even more restricted with the folder being 0700.
#   It looks like this script will need sudo privileges in the end.
#   https://forum.snapcraft.io/t/permissions-of-snap-files-in-var-lib-snapd-snaps/1462/3

# Determine which local snaps are eligible to be copied.
declare -A snaps_to_copy
for snap in ${!snaps_local[@]}; do
    data="${snaps_local[$snap]}"
    rem3="${data#* }"
    rem2="${rem3#* }"

    rev="${data%% *}"
    size="${rem3%% *}"
    state="${rem2% *}"

    # Check to see if local snap has a revision in SNAPS_DIR.
    if [[ ${snaps_avail[$snap]} ]]; then
        # If so, then check if installed revision is higher than available one.
        if [[ $rev -gt ${snaps_top[$snap]} ]]; then
            # If so, add snap to $snaps_to_copy.
            snaps_to_copy["$snap"]="$rev $size $state"
        fi
    else
        # If not, add snap to lists to be copied.
        snaps_to_copy["$snap"]="$rev $size $state"
    fi
done


# 4. Create asserts for installed snaps; store in /tmp folder
# ---------------------------------------------------------------------------
echo "Creating assert files for installed snaps..." | tee -a "$LOG"
echo "-------------------------------------------------------" >> "$LOG"

# Create dictionary of snaps and snap-ids from SNAPD_API.
snaps_addr=v2/snaps
snaps_count=$(snap list | grep -vE '^Name\s*Version.*' | grep -v disabled | wc -l)
json=$(curl --silent --unix-socket "$SOCKET" "$SNAPD_API"/"$snaps_addr")
names=($(echo "$json" | jq ".result[].name"))
ids=($(echo "$json" | jq ".result[].id"))
declare -A snap_ids
i=0
while [[ $i -lt $snaps_count ]]; do
    snap="${names[$i]}"
    # Strip double quotes around snap names.
    snap="${snap#\"}" #}" # the last chars are to fix syntax highlighting in gedit
    snap="${snap%\"}" #}" # ditto

    snap_id="${ids[$i]}"
    # Strip double quotes around snap ids.
    snap_id="${snap_id#\"}" #}" # the last chars are to fix syntax highlighting in gedit
    snap_id="${snap_id%\"}" #}" # ditto
    
    # Add snap and id to dictionary.
    snap_ids["$snap"]="$snap_id"
    ((i++))
done

# Send assert creation to the background & log output to tempfile.
tmp_asserts_dir=$(mktemp -d "$TEMPLATE" --tmpdir)
total_ct="${#snaps_to_copy[@]}"

ct=0
for snap in ${!snaps_to_copy[@]}; do
    data="${snaps_to_copy[$snap]}"
    rem3="${data#* }"
    rem2="${rem3#* }"
    
    rev="${data%% *}"
    state="${rem2% *}"
    snap_id="${snap_ids[$snap]}"
    # Only snaps with [[ state == I ]] need an accompanying assert file.
    if [[ $state != 'I' ]]; then
        continue
    fi

    echo -e "\t${snap}_${rev}.assert" >> "$LOG"
    create_assert_file "$snap" "$rev" "$snap_id" "$tmp_asserts_dir"
    ((ct += 1))
done

# Calculate total size of all snaps to be copied for use in progress window.
total_bytes_to_copy=0
for snap in ${!snaps_to_copy[@]}; do
    data="${snaps_to_copy[$snap]}"
    rem3="${data#* }"
    size="${rem3%% *}"
    ((total_bytes_to_copy += $size))
done
echo -e "\nTotal bytes to copy: $total_bytes_to_copy bytes\n" >> "$LOG"


# 5. Copy eligible snaps and asserts, checking disk space before each one.
# ---------------------------------------------------------------------------
echo "Copying snaps and assert files..." | tee -a "$LOG"
echo "-------------------------------------------------------" >> "$LOG"

# Show progress dialog based on bytes copied.
tmp_copy=$(mktemp "$TEMPLATE" --tmpdir)
bytes_dest_initial=$(($(du -s "$SNAPS_DIR" | cut -f1) * 1024))
bytes_copied=0
(
# Copy each snap only if there is enough room on SNAPS_DIR disk.
for snap in ${!snaps_to_copy[@]}; do
    data="${snaps_to_copy[$snap]}"
    rem3="${data#* }"
    rem2="${rem3#* }"

    rev="${data%% *}"
    size="${rem3%% *}"
    state="${rem2% *}"
    
    # Get size of available space (in B) on SNAPS_DIR disk.
    avail=$(df -B1 --output=avail "$SNAPS_DIR" | tail -n1)
    # Only copy snap and assert if there's enough room.
    if [[ $avail -gt $size ]]; then
        echo -e "0\t$snap\t$rev" >> "$tmp_copy"
        snap_rev="${snap}_${rev}"

        # Source folders for installed snaps.
        if [[ $state == 'I' ]]; then
            src_snaps="$SNAPS"
            src_asserts="$tmp_asserts_dir"
        # Source folders for seeded snaps.
        elif [[ $state == 'S' ]]; then
            src_snaps="$SEEDS"/snaps
            src_asserts="$SEEDS"/assertions
        else
            # Not really possible.
            echo "Snap source location not known. Exiting."  | tee -a "$LOG"
            echo "1" >> "$tmp_copy"
            script_exit 1
            exit 1
        fi

        # Copy snap and assert files to $SNAPS_DIR.
        #   Note: Progress may seem disjointed because files on FAT32 disks are
        #   reported to be written well before they actually are.
        echo -e "\t$snap_rev.snap and $snap_rev.assert" >> "$LOG"
        cp "$src_snaps"/"$snap_rev.snap" "$SNAPS_DIR"/
        cp "$src_asserts"/"$snap_rev.assert" "$SNAPS_DIR"/
        chmod 777 "$SNAPS_DIR"/"$snap_rev"*
    else
        disk=$(df "$SNAPS_DIR" | tail -n1 | tr -s ' ' | cut -d ' ' -f1)
        text="Not enough room left on device $disk.\n\n \
Please clear up some space and try again or use a different disk."
        echo "$text" | tee -a "$LOG"
        if [[ $AUTO -eq 0 ]]; then
            zenity --error "${ZDEFAULTS[@]}" --text="$text" 2>/dev/null
        fi
        echo "1" >> "$tmp_copy"
        script_exit 1
        exit 1
    fi
done
) &
COPY_PID=$!

# Read tempfile to get data for Zenity progress dialog while COPY_PID exists.
text="Copying snaps to:\n\n\
\t$SNAPS_DIR\n\n\
This may take some time, especially on a USB 2.0 device.\n\n \
Copying"

prog_opts="--progress --auto-close"
while [[ $(ps --no-headers -p "$COPY_PID") ]]; do
    bytes_dest_current=$(($(du -s "$SNAPS_DIR" | cut -f1) * 1024))
    bytes_copied=$(($bytes_dest_current - $bytes_dest_initial))
    progress=$(($bytes_copied * 100 / $total_bytes_to_copy - 1))

    ec=$(tail -n1 "$tmp_copy" | cut -f1)
    snap=$(tail -n1 "$tmp_copy" | cut -f2)
    rev=$(tail -n1 "$tmp_copy" | cut -f3)

    if [[ $ec -gt 0 ]]; then
        script_exit "$ec" "$COPY_PID"
    fi
    
    echo "$progress"
    echo "#$text $snap..."
    sleep 0.2
done | zenity ${prog_opts[@]} "${ZDEFAULTS[@]}" 2>/dev/null
ec=$?
if [[ $ec -gt 0 ]]; then
    script_exit "$ec" "$COPY_PID"
fi
# Sync writes to disk before continuing.
echo "Writing cached files to destination..." | tee -a "$LOG"
sync 2>&1 >> "$LOG" &
SYNC_PID=$!

# Show sync progress.
text="Waiting for the disk to finish saving the files...\n\n\n\
This may take some time, especially on a USB 2.0 device.\n"
prog_opts="--progress --pulsate --auto-close --auto-kill --no-cancel"
(
ct=0
while [[ $(ps --no-headers -p $SYNC_PID) ]]; do
    echo "#$text\nElapsed Time: $ct seconds"
    sleep 1
    ((ct++))
done

echo -e "\nInfo: flushing file buffers to disk (sync) took approximately $ct seconds.\n" >> "$LOG"
) | zenity ${prog_opts[@]} "${ZDEFAULTS[@]}" 2>/dev/null


# 6. Delete old revisions, keeping only the $MAX most recent ones.
# ---------------------------------------------------------------------------
# Get snaps in offline directory.
echo "Listing snaps in offline folder..." | tee -a "$LOG"
echo "-------------------------------------------------------" >> "$LOG"

available_list=$(find "$SNAPS_DIR"/ -name '*.snap')
for i in ${available_list[@]}; do
    filename=${i##*/}
    echo -e "\t$filename" >> "$LOG"
done
echo >> "$LOG"

# Build up-to-date dictionary of offline snaps and revisions in SNAPS_DIR.
#   The revision numbers are space-delimited; e.g. ("[skype]"="54 57 ").
declare -A snaps_offline
for a in ${available_list[@]}; do
    name_rev="${a##*/}"
    name_rev="${name_rev%.snap}"
    rev="${name_rev##*_}"
    name="${name_rev%_*}"
    snaps_offline["$name"]+="$rev "
done

# Sort revisions listed for each snap. Remove all but $MAX higest revisions.
echo "Removing old snap versions..." | tee -a "$LOG"
# Create dictionary of snaps and revisions to be removed.
declare -A snaps_removed
for snap in ${!snaps_offline[@]}; do
    sorted=$(
        for r in ${snaps_offline[$snap]}; do
            echo "$r"
        done | sort -nr
        )
    count=1
    for rev in ${sorted[@]}; do
        if [[ $count -le $MAX ]]; then
            # Don't remove snap revision.
            ((count += 1))
        else
            # Select snap revision and assert file for removal.
            snaps_removed["$snap"]+="$rev "
        fi
    done
done

# Remove all snaps and asserts of given revision numbers.
for snap in ${!snaps_removed[@]}; do
    for rev in ${snaps_removed[$snap]}; do
        echo -e "\t${snap}_${rev}.snap and ${snap}_${rev}.assert" >> "$LOG"
        rm -f "$SNAPS_DIR"/"${snap}_${rev}.snap"
        rm -f "$SNAPS_DIR"/"${snap}_${rev}.assert"
    done
done
echo >> "$LOG"
echo "Done." | tee -a "$LOG"

script_exit 0
